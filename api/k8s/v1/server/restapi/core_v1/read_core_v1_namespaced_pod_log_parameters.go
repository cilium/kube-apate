// Code generated by go-swagger; DO NOT EDIT.

// Copyright 2017-2020 Authors of Cilium
// SPDX-License-Identifier: Apache-2.0

package core_v1

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"net/http"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/runtime/middleware"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// NewReadCoreV1NamespacedPodLogParams creates a new ReadCoreV1NamespacedPodLogParams object
// no default values defined in spec.
func NewReadCoreV1NamespacedPodLogParams() ReadCoreV1NamespacedPodLogParams {

	return ReadCoreV1NamespacedPodLogParams{}
}

// ReadCoreV1NamespacedPodLogParams contains all the bound params for the read core v1 namespaced pod log operation
// typically these are obtained from a http.Request
//
// swagger:parameters readCoreV1NamespacedPodLog
type ReadCoreV1NamespacedPodLogParams struct {

	// HTTP Request Object
	HTTPRequest *http.Request `json:"-"`

	/*The container for which to stream logs. Defaults to only container if there is one container in the pod.
	  Unique: true
	  In: query
	*/
	Container *string
	/*Follow the log stream of the pod. Defaults to false.
	  Unique: true
	  In: query
	*/
	Follow *bool
	/*insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the serving certificate of the backend it is connecting to.  This will make the HTTPS connection between the apiserver and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real kubelet.  If the kubelet is configured to verify the apiserver's TLS credentials, it does not mean the connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept the actual log data coming from the real kubelet).
	  Unique: true
	  In: query
	*/
	InsecureSkipTLSVerifyBackend *bool
	/*If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit.
	  Unique: true
	  In: query
	*/
	LimitBytes *int64
	/*name of the Pod
	  Required: true
	  Unique: true
	  In: path
	*/
	Name string
	/*object name and auth scope, such as for teams and projects
	  Required: true
	  Unique: true
	  In: path
	*/
	Namespace string
	/*If 'true', then the output is pretty printed.
	  Unique: true
	  In: query
	*/
	Pretty *string
	/*Return previous terminated container logs. Defaults to false.
	  Unique: true
	  In: query
	*/
	Previous *bool
	/*A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified.
	  Unique: true
	  In: query
	*/
	SinceSeconds *int64
	/*If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime
	  Unique: true
	  In: query
	*/
	TailLines *int64
	/*If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false.
	  Unique: true
	  In: query
	*/
	Timestamps *bool
}

// BindRequest both binds and validates a request, it assumes that complex things implement a Validatable(strfmt.Registry) error interface
// for simple values it will use straight method calls.
//
// To ensure default values, the struct must have been initialized with NewReadCoreV1NamespacedPodLogParams() beforehand.
func (o *ReadCoreV1NamespacedPodLogParams) BindRequest(r *http.Request, route *middleware.MatchedRoute) error {
	var res []error

	o.HTTPRequest = r

	qs := runtime.Values(r.URL.Query())

	qContainer, qhkContainer, _ := qs.GetOK("container")
	if err := o.bindContainer(qContainer, qhkContainer, route.Formats); err != nil {
		res = append(res, err)
	}

	qFollow, qhkFollow, _ := qs.GetOK("follow")
	if err := o.bindFollow(qFollow, qhkFollow, route.Formats); err != nil {
		res = append(res, err)
	}

	qInsecureSkipTLSVerifyBackend, qhkInsecureSkipTLSVerifyBackend, _ := qs.GetOK("insecureSkipTLSVerifyBackend")
	if err := o.bindInsecureSkipTLSVerifyBackend(qInsecureSkipTLSVerifyBackend, qhkInsecureSkipTLSVerifyBackend, route.Formats); err != nil {
		res = append(res, err)
	}

	qLimitBytes, qhkLimitBytes, _ := qs.GetOK("limitBytes")
	if err := o.bindLimitBytes(qLimitBytes, qhkLimitBytes, route.Formats); err != nil {
		res = append(res, err)
	}

	rName, rhkName, _ := route.Params.GetOK("name")
	if err := o.bindName(rName, rhkName, route.Formats); err != nil {
		res = append(res, err)
	}

	rNamespace, rhkNamespace, _ := route.Params.GetOK("namespace")
	if err := o.bindNamespace(rNamespace, rhkNamespace, route.Formats); err != nil {
		res = append(res, err)
	}

	qPretty, qhkPretty, _ := qs.GetOK("pretty")
	if err := o.bindPretty(qPretty, qhkPretty, route.Formats); err != nil {
		res = append(res, err)
	}

	qPrevious, qhkPrevious, _ := qs.GetOK("previous")
	if err := o.bindPrevious(qPrevious, qhkPrevious, route.Formats); err != nil {
		res = append(res, err)
	}

	qSinceSeconds, qhkSinceSeconds, _ := qs.GetOK("sinceSeconds")
	if err := o.bindSinceSeconds(qSinceSeconds, qhkSinceSeconds, route.Formats); err != nil {
		res = append(res, err)
	}

	qTailLines, qhkTailLines, _ := qs.GetOK("tailLines")
	if err := o.bindTailLines(qTailLines, qhkTailLines, route.Formats); err != nil {
		res = append(res, err)
	}

	qTimestamps, qhkTimestamps, _ := qs.GetOK("timestamps")
	if err := o.bindTimestamps(qTimestamps, qhkTimestamps, route.Formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// bindContainer binds and validates parameter Container from query.
func (o *ReadCoreV1NamespacedPodLogParams) bindContainer(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		return nil
	}

	o.Container = &raw

	if err := o.validateContainer(formats); err != nil {
		return err
	}

	return nil
}

// validateContainer carries on validations for parameter Container
func (o *ReadCoreV1NamespacedPodLogParams) validateContainer(formats strfmt.Registry) error {

	return nil
}

// bindFollow binds and validates parameter Follow from query.
func (o *ReadCoreV1NamespacedPodLogParams) bindFollow(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("follow", "query", "bool", raw)
	}
	o.Follow = &value

	if err := o.validateFollow(formats); err != nil {
		return err
	}

	return nil
}

// validateFollow carries on validations for parameter Follow
func (o *ReadCoreV1NamespacedPodLogParams) validateFollow(formats strfmt.Registry) error {

	return nil
}

// bindInsecureSkipTLSVerifyBackend binds and validates parameter InsecureSkipTLSVerifyBackend from query.
func (o *ReadCoreV1NamespacedPodLogParams) bindInsecureSkipTLSVerifyBackend(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("insecureSkipTLSVerifyBackend", "query", "bool", raw)
	}
	o.InsecureSkipTLSVerifyBackend = &value

	if err := o.validateInsecureSkipTLSVerifyBackend(formats); err != nil {
		return err
	}

	return nil
}

// validateInsecureSkipTLSVerifyBackend carries on validations for parameter InsecureSkipTLSVerifyBackend
func (o *ReadCoreV1NamespacedPodLogParams) validateInsecureSkipTLSVerifyBackend(formats strfmt.Registry) error {

	return nil
}

// bindLimitBytes binds and validates parameter LimitBytes from query.
func (o *ReadCoreV1NamespacedPodLogParams) bindLimitBytes(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("limitBytes", "query", "int64", raw)
	}
	o.LimitBytes = &value

	if err := o.validateLimitBytes(formats); err != nil {
		return err
	}

	return nil
}

// validateLimitBytes carries on validations for parameter LimitBytes
func (o *ReadCoreV1NamespacedPodLogParams) validateLimitBytes(formats strfmt.Registry) error {

	return nil
}

// bindName binds and validates parameter Name from path.
func (o *ReadCoreV1NamespacedPodLogParams) bindName(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: true
	// Parameter is provided by construction from the route

	o.Name = raw

	if err := o.validateName(formats); err != nil {
		return err
	}

	return nil
}

// validateName carries on validations for parameter Name
func (o *ReadCoreV1NamespacedPodLogParams) validateName(formats strfmt.Registry) error {

	return nil
}

// bindNamespace binds and validates parameter Namespace from path.
func (o *ReadCoreV1NamespacedPodLogParams) bindNamespace(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: true
	// Parameter is provided by construction from the route

	o.Namespace = raw

	if err := o.validateNamespace(formats); err != nil {
		return err
	}

	return nil
}

// validateNamespace carries on validations for parameter Namespace
func (o *ReadCoreV1NamespacedPodLogParams) validateNamespace(formats strfmt.Registry) error {

	return nil
}

// bindPretty binds and validates parameter Pretty from query.
func (o *ReadCoreV1NamespacedPodLogParams) bindPretty(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		return nil
	}

	o.Pretty = &raw

	if err := o.validatePretty(formats); err != nil {
		return err
	}

	return nil
}

// validatePretty carries on validations for parameter Pretty
func (o *ReadCoreV1NamespacedPodLogParams) validatePretty(formats strfmt.Registry) error {

	return nil
}

// bindPrevious binds and validates parameter Previous from query.
func (o *ReadCoreV1NamespacedPodLogParams) bindPrevious(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("previous", "query", "bool", raw)
	}
	o.Previous = &value

	if err := o.validatePrevious(formats); err != nil {
		return err
	}

	return nil
}

// validatePrevious carries on validations for parameter Previous
func (o *ReadCoreV1NamespacedPodLogParams) validatePrevious(formats strfmt.Registry) error {

	return nil
}

// bindSinceSeconds binds and validates parameter SinceSeconds from query.
func (o *ReadCoreV1NamespacedPodLogParams) bindSinceSeconds(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("sinceSeconds", "query", "int64", raw)
	}
	o.SinceSeconds = &value

	if err := o.validateSinceSeconds(formats); err != nil {
		return err
	}

	return nil
}

// validateSinceSeconds carries on validations for parameter SinceSeconds
func (o *ReadCoreV1NamespacedPodLogParams) validateSinceSeconds(formats strfmt.Registry) error {

	return nil
}

// bindTailLines binds and validates parameter TailLines from query.
func (o *ReadCoreV1NamespacedPodLogParams) bindTailLines(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("tailLines", "query", "int64", raw)
	}
	o.TailLines = &value

	if err := o.validateTailLines(formats); err != nil {
		return err
	}

	return nil
}

// validateTailLines carries on validations for parameter TailLines
func (o *ReadCoreV1NamespacedPodLogParams) validateTailLines(formats strfmt.Registry) error {

	return nil
}

// bindTimestamps binds and validates parameter Timestamps from query.
func (o *ReadCoreV1NamespacedPodLogParams) bindTimestamps(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("timestamps", "query", "bool", raw)
	}
	o.Timestamps = &value

	if err := o.validateTimestamps(formats); err != nil {
		return err
	}

	return nil
}

// validateTimestamps carries on validations for parameter Timestamps
func (o *ReadCoreV1NamespacedPodLogParams) validateTimestamps(formats strfmt.Registry) error {

	return nil
}
